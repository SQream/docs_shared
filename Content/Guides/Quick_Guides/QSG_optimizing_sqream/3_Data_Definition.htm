<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" class="mp-topic" style="mc-master-page: url('../../../Resources/MasterPages/Guides.flmsp');">
    <head>
    </head>
    <body>
        <h2>Data Definition</h2>
        <ul>
            <li>For short ASCII strings (up to 15 bytes), use VARCHAR datatype.
			</li>
            <li>
			For large strings columns (greater than 16 bytes) use NVARCHAR datatypes. </li>
            <div class="note">Non-ASCII characters must use NVARCHAR (as opposed to VARCHAR).</div>
            <li>
                To avoid the need for explicit cast, use INT/BIGINT when possible (as opposed to TINYINT or SMALLINT).
				<div class="note">When an integer reaches its datatype size limitation (tinyint 256, smallint 32767 etc.), SQream will return an overflow.</div></li>
            <li>Not Null constraint:
                <p>Since SQream is a columnar database, it is recommended to define any column that logically cannot contain nulls as 'not null'. </p><p class="example">Example</p><p class="code">Create table my_table (
					A int not null, 
					B nvarchar(100),
					C datetime not null) ; 
					</p></li>
            <li>
                Since SQream is a columnar database that can do JOINS, the issue  of normalizing/not normalizing tables is not critical. Nevertheless, use the following guidelines for making that decision:
				<ul><li>Normalization to fact/dimension (ratio of 1:N) will help to reduce row length size at the fact table, decrease database size, and optimize I/O and GPU utilization at query run time.
					<p>It is highly recommended to use integers (int/bigint) as the join key and not string. </p><table style="width: 100%;border-left-style: solid;border-left-width: 1px;border-right-style: solid;border-right-width: 1px;border-top-style: solid;border-top-width: 1px;border-bottom-style: solid;border-bottom-width: 1px;"><col /><col /><col /><col /><col /><col /><col /><tbody><tr><td><span class="strong">ID</span></td><td><span class="strong">P_Date</span></td><td><span class="strong">Store_ID</span></td><td><span class="strong">Amount</span></td><td>&#160;</td><td><span class="strong">Store_</span>ID</td><td><span class="strong">Store_Name</span></td></tr><tr><td>1</td><td>&lt;date&gt;</td><td>1</td><td>&lt;amount&gt;</td><td>&#160;</td><td>1</td><td>1_store_name</td></tr><tr><td>2</td><td>&lt;date&gt;</td><td>1</td><td>&lt;amount&gt;</td><td>&#160;</td><td>2</td><td>2_store_name</td></tr><tr><td>3</td><td>&lt;date&gt;</td><td>2</td><td>&lt;amount&gt;</td><td>&#160;</td><td>3</td><td>3_store_name</td></tr><tr><td>4</td><td>&lt;date&gt;</td><td>2</td><td>&lt;amount&gt;</td><td>&#160;</td><td>4</td><td>4_store_name</td></tr><tr><td>5</td><td>&lt;date&gt;</td><td>4</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><td>6</td><td>&lt;date&gt;</td><td>1</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><td>7</td><td>&lt;date&gt;</td><td>4</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><td>8</td><td>&lt;date&gt;</td><td>1</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><td>9</td><td>&lt;date&gt;</td><td>2</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr><tr><td>10</td><td>&lt;date&gt;</td><td>4</td><td>&lt;amount&gt;</td><td>&#160;</td><td>&#160;</td><td>&#160;</td></tr></tbody></table></li><li>Choose not to normalize when de-normalization can save join time without resulting in excessive storage requirements (an advantage of high compression ratio).
					</li></ul></li>
        </ul>
    </body>
</html>